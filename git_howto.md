# Подсказка по гиту

## Инициализация репозитория

```sh
git init
```
Команда git init создает проект на локальном компьютере. В дальнейшем, проект можно отправить в удаленный репозитарий
## Статус репозитория

```sh
git status
```
- проверяет является ли папка git-репозитарием
- показывает какие файлы были добавлены или изменены (новый или измененный файл будет отображаться красным цветом)
- если git начнет за ним “следить” (после использования “git add имя_файла”), имя файла будет выделено зеленым цветом
- если файл будет изменен, то git status об этом сообщит (напротив имени файла будет написано **modified**)
- если удалить файл, это тоже отобразится (напротив имени файла будет написано **deleted**)

```sh
git status -s или git status --format = short - сокращенный вывод
```
## Вывод версии

```sh
git --version
```
Выводит весию Git

## Отслеживание и индексация файлов

```sh
git add "имя файла"
```
1) **Отслеживание новых файлов.** Для того чтобы начать отслеживать (добавить под версионный контроль) **новый файл**, используется команда **git add имя_файла** (с расширением). Для нового файла Readme имеем:

```sh
$ git add README

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git restore --staged <file>..." to unstage)
```
<span style="color: red;"> new file: README </span>

2. **Индексация изменённых** (уже отслеживаемых ранее) файлов. Производится использованием той же команды: git add имя_файла (с расширением).
```sh
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
```
<span style="color: red;">new file:   README</span>

<span style="color: red;">modified:   CONTRIBUTING.md</span>

3. **Примечание:** Если вы выполните коммит, то файл имя_файла (с расширением) попадёт в коммит в том состоянии, в котором он находился, когда вы последний раз выполняли команду git add , а не в том, в котором он находится в вашем рабочем каталоге в момент выполнения git commit. Если вы изменили файл после выполнения git add, вам придётся снова выполнить git add, чтобы проиндексировать последнюю версию файла

## Фиксация
```sh 
git commit -m “commit message”

```
создает коммит с указанным комментарием

```sh 
git commit -a -m “commit message”

```
аналогичен запуску двух команд:git add для всех файлов, которые существовали в предыдущем коммите, и git commit. Это удобно, но: флаг -a может включить в коммит нежелательные изменения.

## Демонстрация изменений

```sh
git diff
```
если необходимо узнать, что конкретно поменялось, а не только какие файлы были изменены, можно использовать команду git diff. Используя эту команду можно получить ответы на два вопроса: что было изменено, но ещё не проиндексировано, и что проиндексировано и можно включить в коммит. Команда git diff показывает непосредственно добавленные и удалённые строки — патч как он есть. 
- увидеть, что было изменено, но пока не проиндексировано, можно используя команду git diff без аргументов: git diff. Эта команда сравнивает содержимое рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения. Если проиндексировать все изменения, то git diff ничего не вернёт
- посмотреть, что было проиндексировано и что войдёт в следующий коммит можно используя команду   
git diff --staged. Она сравнивает проиндексированные изменения с последним коммитом
- посмотреть текущие изменения в рабочей копии,
- предыдущие изменения в коммитах,
- для сравнения ветвей.

## Отображение истории коммитов
```sh
git log
```
git log (по умолчанию)- отображает историю всех коммитов, начиная с самого позднего (контрольную сумму, автора, адрес электронной почты автора, дату создания и сообщение коммита)
- git log -p или --patch - показывает разницу (патч), внесенную в каждый коммит. Можно ограничить количество записей добавлением числа -2, -3 и т.д.
- Чтобы увидеть сокращённую статистику для каждого коммита, можно использовать опцию --stat
- опция --oneline выводит каждый коммит в одну строку
- format - опция, которая позволяет указать формат для вывода информации. Полезным когда необходимо сгенерировать вывод для автоматического анализа — так как можно указывать формат явно, он не будет изменен даже после обновления Git.
- **Полезные опции для** `git log --pretty=format`
    
    %H - Хеш коммита;   
    %h - Сокращённый хеш коммита;   
    %T - Хеш дерева;    
    %t - Сокращённый хеш дерева;    
    %P - Хеш родителей; 
    %p - Сокращённый хеш родителей; 
    %an - Имя автора;   
    %ae - Электронная почта автора; 
    %ad - Дата автора (формат даты можно задать опцией  -  - date=option);  
    %ar - Относительная дата автора;    
    %cn - Имя коммитера;    
    %ce - Электронная почта коммитера;  
    %cd - Дата коммитера;   
    %cr - Относительная дата коммитера; 
    %s - Содержание.

    Пример:
    ```sh
    $ git log --pretty=format:"%h - %an, %ar : %s"
    ```
- опции oneline и format совместно с опцией --graph команды log позволяют увидеть небольшой граф в формате ASCII, который показывает текущую ветку и историю слияний
    Пример:
    ```sh
    $ git log --pretty=format:"%h %s" --graph
    ```
- Наиболее распространённые опции для команды git log.

-p - Показывает патч для каждого коммита;
--stat - Показывает статистику изменённых файлов для каждого коммита.   
--shortstat - Отображает только строку с количеством изменений/вставок/удалений для команды --stat; 
--name-only - Показывает список изменённых файлов после информации о коммите;   
--name-status - Показывает список файлов, которые добавлены/изменены/удалены;   
--abbrev-commit - Показывает только несколько символов SHA-1 чек-суммы вместо всех 40;  
--relative-date - Отображает дату в относительном формате (например, «2 weeks ago») вместо стандартного формата даты;   
--graph - Отображает ASCII граф с ветвлениями и историей слияний;   
--pretty - Показывает коммиты в альтернативном формате. Возможные варианты опций: oneline, short, full, fuller и format (с помощью последней можно указать свой формат);    
--oneline - Сокращение для одновременного использования опций --pretty=oneline --abbrev-commit.

## Операции отмены

```sh
$ git commit --amend
```
- если необходимо переделать коммент, достаточно внести необходимые изменения, добавить их в индекс и сделать коммит ещё раз, указав параметр --amend. Команда позволяет переделать коммит, в случае, если нужно добавить какие-то файлы или комментарий к коммиту. Эта команда использует область подготовки (индекс) для внесения правок в коммит. Если ничего не было изменено с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, но можно будет изменить сообщение к коммиту. Запустится тот же редактор, только он уже будет содержать сообщение предыдущего коммита. Можно будет отредактировать сообщение как обычно, однако, оно заменит сообщение предыдущего коммита.

- отмена индексации файла

```sh
git reset HEAD <file>
```
команда исключения файла из индекса. Позволяет исключить из индекса, например, ошибочно добавленный файл

- отмена изменений в файле
    - git restore - отменяет изменения в измененном файле

    - git restore --staged имя_файла - отменяет индекс файла, т.е. это обратная операция git add  имя_файла. Далее, применив предыдущую команду git restore имя_файла, можно отменить изменения файла и вернуть к состоянию после последнего коммита.    Отменить изменения в файле — вернуть к тому состоянию, которое было в последнем коммите

## Переключения веток и выгрузка их содержимого в рабочий каталог

```sh
git checkout

```
   - git chekout master загружает ветку master
   - Можно загрузить версию сохранения файла по коммит идентификатору. После команды достаточно ввести первые 4 символа коммит идентификатора  (хэш коммита)
   - git checkout -b new_branch_name - создание ветки new_branch_name с переключением на нее.
   - git switch -c new_branch_name - аналог команды git checkout -b new_branch_name. Вместо -с можно использовать --create
   - git switch - вернуться к предыдущей извлеченной ветки

## Удаление файлов

```sh
git rm

```
- Для того чтобы удалить файл из Git, необходимо удалить его из отслеживаемых файлов (точнее, удалить его из индекса) а затем выполнить коммит
    - если просто удалить файл rm PROJECTS.md из рабочего каталога, он будет показан в секции «Changes not staged for commit» (изменённые, но не проиндексированные)
    - затем, если выполнить команду git rm PROJECTS.md, удаление файла попадёт в индекс
    - После следующего коммита файл исчезнет и больше не будет отслеживаться.
- если файл был изменен и уже проиндексирован необходимо использовать принудительное удаление с помощью параметра -f. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git
- $ git rm --cached "имя файла" позволяет оставить файл на жёстком диске, но перестать отслеживать изменения в нём. Это полезно, например, если что-то не было добавлено в файл .gitignore и по ошибке было проиндексировано, например, большой файл с логами, или большое количество промежуточных файлов компиляции. Чтобы сделать это, следует использовать опцию --cached
- В команду git rm можно передавать файлы, каталоги или шаблоны. Например, так:
git rm log/\\\*.log.  При вводе команды используется обратный слеш (\\) перед \*. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику командного интерпретатора. Эта команда удаляет все файлы, имеющие расширение .log и находящиеся в каталоге log/. Можно также сделать следующим образом: git rm \\*~
Эта команда удаляет все файлы, имена которых заканчиваются на ~.

## Переименование файлов
```sh
git mv file_from file_to
```
Например,
```sh
git mv README.md README
```
эквивалентно: 
```sh  
mv README.md README
git rm README.md
git add README
```
## Создание новой ветки
```sh
git branch
```
- git branch newbranchname - создает ветку, но не переключает ее
- git checkout -b newbranchname при создает новую ветку и переключается на нее
- git switch -c new-branch -другой вариант создания ветки и переключения на нее. Флаг -c означает создание, но также можно использовать полный формат:` --create`

## Переключение на другую ветку
```sh
git checkout branchname
```
переключает на ветку branchname
- git switch также можно использовать вместо git checkout в следующих случаях:
    - Переключиться на существующую ветку: git switch testing_branch
    - Вернуться к предыдущей извлечённой ветке: git switch -

## Слияние веток
```sh
git checkout master
git merge branchname
```
- первая команда осуществляет переключение на ветку master в которую необходимо внести изменение 
- вторая осуществляет слияние ветки branchname с master и таким образом вносит изменения в ветку master из ветки branchname


## Удаление ветки
```sh
git branch -d branchname
```
команда удаления ветки branchname

## Разрешение конфликтов слияния
```sh
git mergetool
```
 запускает графический инструмент для разрешения конфликтов. Проводит по всем конфликтам

## Управление ветками
```sh
git branch -v  
```
Показывает последний коммит на каждой из веток
```sh
git branch --merged
```
Показывает ветки, которые были уже слиты с текущей

```sh
git branch --no-merged
```
Показывает все ветки, содержащие наработки, которые ещё не были слиты в текущую ветку
```sh
git branch -D testing
```
удаляет ветку вместе со всеми наработками

## Переименование ветки
```sh
git branch --move branch_name_old branch_name_new
```
- Ветка bbranch_name_old будет переименована в branch_name_new
```sh
git push --set-upstream origin branch_name_new
git push origin --delete branch_name_old
```
- Первая команда позволит перенести исправленную ветку в удалённый репозитории
- Вторая - удалит старую ветку из удаленного репозитория branch_name_old

## Удалённые ветки
```sh
git ls-remote <remote>
```
- выводит список удалённых ссылок
```sh
git remote show <remote>
```
- получение списка удалённых веток и дополнительной информации

```sh
git push <remote> <branch>
```
- отправить ветку <branch> на удаленный сервер
```sh
git checkout -b serverfix origin/serverfix
```
- создание на основе ветки слежения origin/serverfix локальной ветки serverfix, в которой можно работать 
```sh
git checkout -b <branch> <remote>/<branch>
```
или
```sh
git checkout --track origin/serverfix
```

- настроить отслеживание и ветки <branch> на удаленном сервере

```sh

git checkout -b <another_name> origin/<name>
```
- создать локальную ветку с именем, отличным от имени удалённой ветки
```sh
git branch -u origin/serverfix
```
- настроить существующую локальную ветку serverfix на слежение за удалённой веткой с тем же именем

```sh
git branch -vv
```
- выведет список локальных веток и дополнительную информацию о том, какая из веток отслеживается, отстаёт, опережает или всё сразу относительно отслеживаемой. Эта команда не обращается к серверам, а лишь говорит вам о том, какая информация с этих серверов сохранена в локальном кэше
```sh
git fetch --all; git branch -vv
```
 - для получения актуальной информации перед запуском команды git branch -vv необходимо обновить данные со всех удалённых серверов, используя команду git fetch --all

 ## Удаление ветки

```sh
git push origin --delete <branch_name>
```
- команда удаления ветки на сервере

## Перебазирование ветки
```sh
git checkout experiment
git rebase master
git checkout master
git merge experiment
```
- (команда 1-2) изменяет ветку master содержимым ветки experiment. Текущая ветка устанавливается на последний коммит ветки, поверх которой выполняетеся перебазирование
- (команда 3-4) далее можно переключиться обратно на ветку master и выполнить слияние перемоткой

rebase подтверждает, что изменения заданной ветки не конфликтуют с изменениями целевой ветки. Если существует конфликт слияния (merge conflict), возможно выполнить rebase, чтобы исправить его.
```sh
git rebase --onto master server client
```
- В этой команде говорится: «Переключись на ветку client, найди изменения относительно ветки server и примени их для ветки master»
```sh
git rebase master server
```
- команда осуществляет перебазирование ветки server относительно ветки master без предварительного переключения на неё

```sh

```
```sh

```
```sh

```